<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Day 01 - task</title>
    <link rel="stylesheet" href="./CSS/style.css" />
  </head>
  <body>
    <header>Day one - Task (by - Udhayasooriyan)</header>
    <nav>
      <a href="#dif">Diff B/W HTTP1.1 & HTTP2</a>
      <a href="#obj">objects and its internal representation in Javascript</a>
    </nav>
    <div class="wrapper" id="dif">
      <nav>
        <a href="#dif">Diff B/W HTTP1.1 & HTTP2</a>
        <a href="#obj">objects and its internal representation in Javascript</a>
      </nav>
      <h1>Difference between HTTP1.1 vs HTTP2</h1>
      <p class="overview">
        HTTP stands for hypertext transfer protocol & it is used in
        client-server communication. By using HTTP user sends the request to the
        server & the server sends the response to the user. There are several
        stages of development of HTTP but we will focus mainly on HTTP/1.1 which
        was created in 1997 & the new one is HTTP/2 which was created in 2015.
      </p>
      <h3>HTTP/1.1:</h3>
      <p>
        For better understanding, let’s assume the situation when you make a
        request to the server for the google.co.in page & server responds to you
        as a resource google.co.in page. before sending the request and the
        response there is a TCP connection established between client & server.
        again you make a request to the server for image img.jpg & the server
        gives a response as an image img.jpg. the connection was not lost here
        after the first request because we add a keep-alive header which is the
        part of the request so there is an open connection between the server &
        client. there is a persistent connection which means several requests &
        responses are merged in a single connection. These are the drawbacks
        that lead to the creation of HTTP/2: The first problem is HTTP/1.1
        transfer all the requests & responses in the plain text message form.
        The second one is head of line blocking in which TCP connection is
        blocked all other requests until the response does not receive. all the
        information related to the header file is repeated in every request.
      </p>
      <h3>HTTP/2:</h3>
      <p>
        HTTP/2 was developed over the SPDY protocol. HTTP/2 works on the binary
        framing layer instead of textual that converts all the messages in
        binary format. it works on fully multiplexed that is one TCP connection
        is used for multiple requests. HTTP/2 uses HPACK which is used to split
        data from header. it compresses the header. The server sends all the
        other files like CSS & JS without the request of the client using the
        PUSH frame.
      </p>
      <h3>Difference between HTTP/1.1 and HTTP/2 are:</h3>
      <table>
        <tr>
          <th>HTTP/1.1</th>
          <th>HTTP/2</th>
        </tr>
        <tr>
          <td>It works on the textual format.</td>
          <td>It works on the binary protocol.</td>
        </tr>
        <tr>
          <td>
            There is head of line blocking that blocks all the requests behind
            it until it doesn’t get its all resources.
          </td>
          <td>
            It allows multiplexing so one TCP connection is required for
            multiple requests.
          </td>
        </tr>
        <tr>
          <td>
            It uses requests resource Inlining for use getting multiple pages
          </td>
          <td>It uses PUSH frame by server that collects all multiple pages</td>
        </tr>
        <tr>
          <td>It compresses data by itself.</td>
          <td>It uses HPACK for data compression.</td>
        </tr>
      </table>
    </div>
    <div class="wrapper" id="obj">
      <h1>objects and its internal representation in Javascript</h1>
      <p>
        In Javascript, objects are an essential data type that is used
        extensively to represent real-world entities, data structures, and more.
        An object is a collection of properties, where each property is a
        key-value pair. Javascript objects can be created using object literals,
        constructor functions, or classes. In this blog, we'll explore the
        internal representation of objects in Javascript.
      </p>
      <p>
        Object Structure When an object is created in Javascript, it is
        allocated in memory as a contiguous block of memory known as an object
        slot. The object slot consists of three parts: a hidden class, the
        property data, and the elements data. The hidden class is an internal
        data structure used by the Javascript engine to optimize property access
        and reduce memory usage. The property data is a map-like data structure
        that stores all the named properties of the object. The elements data is
        an array-like data structure that stores all the integer-indexed
        properties of the object.
      </p>
      <p>
        Property Access To access a property of an object in Javascript, the
        engine first checks if the property exists in the property data. If the
        property is found, the value is returned. If the property is not found
        in the property data, the engine checks the hidden class to see if the
        property is defined on the object's prototype chain. If the property is
        found, the value is returned. If the property is not found in the hidden
        class, the engine checks the elements data to see if the property is an
        integer-indexed property. If the property is found, the value is
        returned. If the property is not found in any of the data structures,
        undefined is returned.
      </p>
      <p>
        Property Addition and Deletion When a property is added to an object in
        Javascript, the engine first checks if the hidden class of the object is
        compatible with the new property. If the hidden class is compatible, the
        property is added to the property data. If the hidden class is not
        compatible, the engine creates a new hidden class that includes the new
        property and all the existing properties, and the property is added to
        the new hidden class's property data. When a property is deleted from an
        object, the property is removed from the property data, and the hidden
        class is updated to reflect the change.
      </p>
      <p>
        Property Enumeration Javascript objects have a built-in method called
        Object.keys() that returns an array of all the object's own enumerable
        properties. To enumerate all properties of an object, including
        inherited properties, you can use a for...in loop. The for...in loop
        iterates over all enumerable properties of an object and its prototype
        chain. In conclusion, Javascript objects are a powerful data type that
        is used extensively in modern web development. The internal
        representation of objects in Javascript is complex but efficient,
        allowing for fast property access and memory optimization. Understanding
        the internal representation of objects in Javascript can help developers
        write more efficient and performant code.
      </p>
    </div>
  </body>
</html>
